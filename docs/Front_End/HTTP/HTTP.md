---
typora-root-url: images
---


# HTTP进化史
HTTP协议（HyperText Transfer Protocol，*超文本传输协议*）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准，可以说Web是建立在HTTP协议上通信的。

> 准确的说HTTP应该翻译为超文本转移协议。

在学习过程中，大瑞遇到几个疑问：

- 超文本一词是如何诞生的？
- HTTP出现以前，计算机之间是如何通信的？
- HTTP诞生后的发展过程？

有问题那就查嘛，于是就有了下面的内容。

早在上世纪三十年代，美国 MIT 工程学院的电子工程师 Vannevar Bush（我也不知道怎么读~）就提出了一种信息扩展存储器的设想：

>  可以将聚合起来的知识存储在微缩胶卷上，可以极其方便快速地查阅。并且这些信息应当有上下文关联性，就像人类大脑构建的知识链接那样。

尽管他设想的扩展存储器系统从未实现，其思想却影响了后来者。

1965 年，**超文本**一词首次出现在 Ted Nelson 发表的文章中，Nelson 是一位软件设计师。这位大佬提出的超文本一词含义如下：

> 大量的书面材料或图像材料以复杂的方式相互联系，因此不便在纸介质上呈现或展示。其中可能包含内容摘要，或者内容分布的脉络图以及各部分的内在联系；也可能包含审阅过其中内容的学者所添加的注释、补充或脚注。

Nelson 想要建立“文档库”，让信息之间互相关联，永不删除，并且方便所有人获取。20 世纪 70 年代，基于 Bush 的思想，Nelson 在他的 Xanadu 项目中实现了一个超文本系统的原型。

很遗憾，该项目没有完成，但为后来者提供了基础，没白忙活。

1975年1月，世界上第一台个人计算机 `Altiar 8800 `诞生。随后的十年间，个人计算机迎来高速发展。在这期间计算机面临一个问题：如何解决个人计算机之间的信息共享？

- 独立模式

​	   在计算机发展的早期阶段，计算机都是以单机模式（独立模式）运行的。各个终端之间信息不能共享。计算机之间完全是割裂的，就像你手机开不了流量连不了无线，也没有蓝牙，可以想象下有多痛苦。

![独立模式](/1.jpg)

- 网络互联模式

为解决单机某事的痛点，网络互联模式诞生。

网络互联模式将一个个计算机连接在一起，形成一个计算机网络。连接多台计算机可以实现信息共享，同时还能在两台物理位置较远的机器之间即时传递信息。

![网络互联模式](/2.jpg)

网络互联模式又分为两种模式，根据其规模可分为WAN（Wide Area Network，广域网）和LAN（Local Area Network，局域网）

> - 广域网指覆盖多个远距离区域的远程网络。
>
> - 比广域网再小一级的、连接整个城市的网络叫城域网(MAN, Metropolitan Area Network）。
> - 局域网指一个楼层、一栋楼或一个校园等相对较小的区域内的网络。

![广域网](/4.jpg)

![局域网](/3.jpg)

这两个技术使多台物理空间较远的机器之间的信息共享的需求得以实现。形成早期的计算机网络。

但广域网与局域网本质上还是各个独立团体或者公司之间的私有网络，这时人们想要将各个私有网络连接为更大的私有网络。广域网与局域网也为自身技术限制暂时不能满足这种需求。

- 诞生

​	    时间来到了1989年3月，CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李提出了一种能让远隔两地的研究者们共享信息的设想。基本理念是通过借助多文档之间相互关联形成的**超文本**，连成可相互参阅的WWW(万维网)。

> WWW(万维网)构成：
>
> - 把SGML作为页面的文本标记语言的HTML
> - 作为文档传递协议的HTTP
> - 指定文档所在地址的URL

​	1990年1月，CERN研发出世界上第一台Web服务器和Web浏览器。

​	1991年，HTTP/0.9发布。至此HTTP 诞生。

## HTTP/0.9

HTTP/0.9的诞生具有划时代的意义，它打破了计算机信息数据共享的物理空间限制。

但是它并不完美：

- 仅支持GET方法
- 没有HEADER等数据描述信息
- 服务端发送完毕即断开TCP连接
- 可发送的数据仅限于HTML格式的字符串
- 设计目标就是获取HTML

​         在1991年-1996年期间，HTTP的发展一直处于驻足不前的状态。伴随HTTP的诞生，创办网景公司的马克·安德森于1994年发布了第一款浏览器Netscape0.9。让数百万用户第一次涌入了互联网世界的大门。开启了Web时代。

​		当时以操作系统一统天下的微软意识到了网景浏览器对于操作系统的威胁。于1996买下Mosaic，开发了IE，浏览器大战，一触即发。后来就是微软利用其自身操作系统市场份额的优势，坐上了浏览器市场的头把交椅。

​		浏览器大战，导致两家公司无视Web发展标准，各自对HTML进行扩展。最终导致前端工程师在开发时不得不考虑浏览器的兼容问题。

## HTTP/1.0

时间来到了1996年5月，由于HTTP0.9自身的局限性太多，所以针对其限制，HTTP/1.0 横空出世。协议雏形形成。

- 可发送内容格式：图像、视频、二进制文件、文字。
- 新增支持方法：POST、PUT、HEAD、DELETE、LINK、UNLINK
- 优化请求格式：头信息 + 元数据
  - 头信息可用于描述元数据
- 新增状态码：1XX、2XX、3XX、4XX、5XX
  - 明确客户端与服务端处理请求的状态
- 新增其他内容：多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。

主要缺点：

- 每个TCP连接只能发送一个请求。发送数据完毕，连接就会关闭，如果还要请求其他资源，就必须重新建立连接。
- 由于TCP的连接与断开过程成本大，尤其是当一个网页加载过多外部资源的时候，会给客户端与服务端之间的通信造成巨大压力。

## HTTP/1.1

1997年1月，HTTP/1.1 发布，只比 HTTP/1.0 版本晚了半年。可将它视为对1.0的补丁。

HTTP/1.1 一直用到了20年后的今天，直到现在还是最流行的版本。相较于HTTP/1.0，HTTP/1.1做了以下改进：

- 引入持久连接 。Connection： keep-alive， 解决1.0中频繁需要进行TCP连接的问题，减少了建立和关闭连接的消耗和延迟。
- 管线化传输（pipelining）。允许同时发送多个请求，不需要一个接一个的等待请求响应。允许在同一TCP连接中发送多个请求。
- Content-Length 字段。一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。
- 分块传输编码。
- 增强缓存处理，进一步完善协商缓存与强制缓存。在 HTTP1.0 中主要使用 header 里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
- 完善HEADER信息，新增状态码，新增请求方法：OPTIONS、TRACE、CONNECT。

主要问题：

- 队头阻塞。复用TCP连接虽减少了重复连接的损耗，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。
- 头信息臃肿。因为1.1给HEAD新增了一些描述请求的信息。在一定程度上增加了传输的成本。
- 持久连接给服务端造成的性能压力。
- 数据安全。1.1 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。

## HTTPS

​		前面说了，HTTP传输数据时都是明文传输的，这就导致我们在填写的表达的账号和密码被Hacker窃听或者篡改。造成很大的安全问题。

HTTPS的出现就是为了解决数据传输过程中的安全问题而生的。我们知道HTTP位于网络七层协议的应用层，而在他之下就是负责建立TCP连接的网络层，如果我们相对数据进行加密，肯定是在数据连接传输之间就做好工作。所以HTTPS就是在HTTP和TCP/IP之间再加一层TLS（传输层安全性协议）或者SSL（安全套接层）。

​		而数据加密的工作就是由SSL完成的，这里的加密方式有两种对称加密和非对称加密，两者的区别在于加密与解密的钥匙是否唯一。这两种方式仍有问题，就是没办法判定"你到底是不是你？"，于是引入了数字证书，数字证书是由权威机构——CA机构统一来进行发行，用来证明"你就是你"。这个过程有点像我们淘宝购物时支付宝在卖家与买家之间担当的角色。

HTTPS就是通过TLS/SSL+CA机构解决的安全问题。

​		但是引入TLS/SSL协议也带来了新的问题，当我们通过TCP/IP建立连接时需要通过三次握手，但是当加入SSL后，会增加我们的握手时间，因为这里需要完成加密套件的协商和证书的身份确认及连接数字证书的颁发机构CA，以确定正式的有效性。

​		针对这个问题，我们先留着，接着往下说。

## HTTP/2.0



​		自从 HTTP/1.1以来，互联网由Web浏览器时代发展为移动互联网时代，发生了翻天覆地的变化。最早大小只有几千字节、包含资源只有个位数、主要基于文本的网页，如今已发展为平均大小超过 2MB**1**、包含资源数平均为 140 的富媒体网站。然而，用来传输 Web 内容的 HTTP 协议这些年并没有什么变化。

​		于是一个新的工种出现了：Web 性能专家，他们精于发掘变通办法，在原有协议上提升网页加载速度，我们现在所采用的多数Web性能优化手段就诞生于此。大家对性能的期望也改变了——在 20 世纪 90 年代后期，大家愿意为一个页面等上 7 秒，而技术和市场调研公司 Forrester Research 在 2009 年的一项研究中发现，在线购物者期望单个页面能在 2 秒内完成加载，其中很大一部分用户会放弃加载时间超过 3 秒的页面。近期 Google 的一项研究表明，甚至 400 毫秒（一眨眼的时间）的延迟，都可能降低人们的搜索意愿。

​		这就是 HTTP/2.0 诞生的原因——该协议可以更好地适应如今的复杂页面，同时又不牺牲速度。 HTTP/2 的应用在不断增多，因为越来越多的网站管理员意识到，他们可以借此花很小的成本来提高他们网站的感知性能。

这里需要先补习一下SPDY协议，它是HTTP/2.0诞生的基础。

## SPDY 协议

![SPDY协议](/SPDY.png)

2009年Google的两位工程师 Mike Belshe 和 Roberto Peon 提出了一种弥补HTTP传输数据过程中各种不足的协议： SPDY（发音同 speedy）。SPDY并不是一种用于替代HTTP的协议，而是对[HTTP](https://baike.baidu.com/item/HTTP)协议的增强。据说用了这个协议后页面加载速度提高64%。SPDY主要就是为了解决**传输速度**与**数据安全性**的问题：

- 复用流：SPDY允许在一个连接上无限制并发流。因为请求在一个通道上，TCP效率更高：更少的网络连接，发出更少更密集的数据包。
- **降低延迟：** 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（Multiplexing）。多路复用通过多个请求stream共享一个TCP连接的方式，降低了创建多个TCP的延迟同时提高了带宽的利用率。
- **请求优先级（Request Prioritization）：** 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
- **header压缩：** SPDY压缩请求和响应HTTP报头，从而减少传输的数据包数量和字节数。HTTP1.1的header很多时候都是重复多余的，而有些header的内容在不压缩的情况下则比较“庞大”。选择合适的压缩算法可以减小包的大小和数量，不仅可以节省资源，还可以缩短数据传递的延迟。
- **基于HTTPS的加密协议传输：** 保留了HTTPS的TLS加密特性，大大提高了传输数据的可靠性。
- **服务端推送（Server Push）：** 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将index.js的文件推送给客户端，当客户端再次尝试获取index.js时就可以直接从缓存中获取到，不用再发请求了。

## HTTP/2.0

​		谷歌设计使用SPDY协议的这套操作被[互联网工程任务组](https://baike.baidu.com/item/互联网工程任务组)（[IETF](https://baike.baidu.com/item/IETF)）盯上，并且发现这东西顶好，可以吸收进来，于是将SPDY协议进行了标准化后，在2015年5推出了类似于SPDY协议的 [HTTP 2.0](https://baike.baidu.com/item/HTTP 2.0) 协议标准（简称HTTP/2）。谷歌一看这都被整合到新的HTTP/2.0中了，我还维护它干什么，于是也就停止了对SPDY协议的继续维护与支持。转而使用HTTP/2.0。

HTTP/2.0继承了SPDY协议的优点：

- 二进制格式（Binary Format） 。HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。
- 多路复用（MultiPlexing） 。即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- 请求优先级。
  - 把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。
  - 服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。
  - HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。
- HEADER压缩。
  - HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
  - HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。
  - 一方面，头信息使用Gzip或compress压缩后再发送；
  - 另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
- 服务端推送。HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
  - 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。



​		启用HTTP/2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对http 2.0下的TCP配置优化至关重要。

## HTTP/3.0

2015年，Google基于QUIC协议创建了HTTP3.0。

QUIC协议针对基于TCP和TLS的HTTP2.0协议解决了下面的问题：

- 减少了TCP三次握手及TLS握手时间。 不管是HTTP1.0/1.1还是 HTTPS，HTTP2.0，都使用了TCP进行传输。HTTPS和HTTP2还需要使用TLS协议来进行安全传输。这就出现了两个握手延迟，而QUIC协议是基于UDP协议进行构建，UDP 协议本身没有连接的概念，连接建立时只需要一次交互，半个握手的时间。

- 多路复用丢包时的线头阻塞问题。 QUIC保留了HTTP2.0多路复用的特性，但是即使在多路复用过程中，同一个TCP连接上有多个stream，假如其中一个stream丢包，在重传前后续的stream都会受到影响，而QUIC中一个连接上的多个stream之间没有依赖。所以当发生丢包时，只会影响当前的stream，也就避免了线头阻塞问题。

- 优化重传策略。以往的TCP丢包重传策略是：在发送端为每一个封包标记一个编号 (sequence number)，接收端在收到封包时，就会回传一个带有对应编号的ACK封包给发送端，告知发送端封包已经确实收到。当发送端在超过一定时间之后还没有收到回传的 ACK，就会认为封包已经丢失，启动重新传送的机制，复用与原来相同的编号重新发送一次封包，确保在接收端这边没有任何封包漏接。 这样的机制就会带来一些问题，假设发送端总共对同一个封包发送了两次 (初始 + 重传)，使用的都是同一个sequence number：编号N。之后发送端在拿到编号N封包的回传ACK 时，将无法判断这个带有编号N的ACK，是接收端在收到初始封包后回传的ACK。这就会加大后续的重传计算的耗时。QUIC为了避免这个问题，发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，unique packet number，每一个编号都唯一而且严格递增，这样每次在收到ACK时，就可以依据编号明确的判断这个ACK是来自初始封包或者是重传封包。

- 流量控制。 通过流量控制可以限制客户端传输资料量的大小，有了流量控制后，接收端就可以只保留相对应大小的接收 buffer，优化记忆体被占用的空间。但是如果存在一个流量极慢的stream ，光一个stream就有可能佔用掉接收端所有的资源。QUIC为了避免这个潜在的HOL Blocking，采用了连线层 (connection flow control) 和 Stream 层的 (stream flow control) 流量控制，限制单一 Stream 可以占用的最大buffer size。

- 连接迁移。 TCP连接基于四元组（源 IP、源端口、目的 IP、目的端口），切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的 TCP 连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，当检测到网络变化时立刻建立新的 TCP 连接，即使这样，建立新的连接还是需要几百毫秒的时间。 QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，对应每个stream，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。

作者：吕小鸣
链接：https://juejin.im/post/6844903988953874445

## HTTP请求方法

- GET 获取资源，用来请求访问已被URI识别的资源。
- POST 传输实体主体，一般用于表单内容的提交。
- PUT 传输文件
- HEAD 获得报文首部，用于确认URI的有效性及资源更新的日期时间。
- DELETE 删除文件
- OPTIONS 询问支持的方法
- TRACE 追踪路径，让Web服务器端将之前的请求通信返回给客户端的方法。
- CONNECT 要求用隧道协议连接代理，要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL和TLS协议把通信内容加密后经网络隧道传输

>  面试题：GET方法与POST方法相比有什么区别？POST方法可以用来获取资源吗？

## HTTP状态码

​		HTTP状态码最早出现在HTTP/1.0中，在后续的版本中有进行了完善。状态码主要表示客户端HTTP请求的返回结果、标记服务器端的处理状态是否正常、通知出现的错误等工作。

- 状态码的类别

|      | 类别                             | 原因短语                   |
| :--: | :------------------------------- | -------------------------- |
| 1XX  | 信息状态码（Informational）      | 接受的请求正在处理         |
| 2XX  | 成功状态码（Success）            | 请求正常处理完毕           |
| 3XX  | 重定向状态码（Redirection）      | 需要进行附加操作以完成请求 |
| 4XX  | 客户端错误状态码（Client Error） | 服务器无法处理请求         |
| 5XX  | 服务端错误状态码（Server Error） | 服务器处理请求出错         |

- 2XX 成功，响应结果表明请求被正常处理。
  - 200 OK，表示客户端发来的请求在服务器端被正常处理。
  - 204 No Concent，表示服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主题部分。
  - 206 Partial Content，表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。
- 3XX 重定向，表明浏览器需要执行某些特殊的处理以正确处理请求。
  - 301 Moved Permanently，永久性重定向，表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI
  - 302 Found ，临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户能使用新的URI访问。
  - 303 See  Other，表示请求对应的资源存在着另一个URl，应使用GET方法定向获取请求的资源。
  - 304 Not Modified，表示客户端发送附带条件的请求时，服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。
  - 307 Temporary Rediect，临时重定向。该状态码与302 Found 有着相同的含义。

- 4XX 客户端错误，响应结果表明客户端是发生错误的原因所在。
  - 400 Bad Request，该状态码表示请求报文中存在语法错误。
  - 401 Unauthorized，该状态码表示请求需要有通过HTTP认证的认证信息。
  - 403 Forbidden，该状态码表明请求资源的访问被服务器拒绝了。
  - 404 Not Found，表明服务器上无法找到请求的资源。
- 5XX 服务器错误，表明服务器本身发生错误
  - 500 Internal Server Error，表明服务器端在执行请求时发生了错误
  - 503 Service Unavailable，表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。



## HTTP报文首部



报文结构：报文首部 + 空行 + 报文主体

​		HTTP协议的请求和响应报文中必定包含HTTP首部，首部内容为客户端和服务端分别处理请求和响应提供所需要的信息。

### HTTP 请求报文

​		请求报文由方法、URI、HTTP版本、HTTP首部字段等部分构成。





### HTTP响应报文











